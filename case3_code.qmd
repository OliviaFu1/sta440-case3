---
title: "case3_code"
format: html
editor: visual
---

# Data

```{r}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(tidyr)
```

```{r}
load("./emsData.RData")
```

# EDA

```{r}
# remove duplicated entries of the same call
# 5 duplicates
x <- x |>
  distinct(VEH.GRID, DT.DISP, .keep_all = TRUE)
```

## Problem in North

```{r}
x |>
  mutate(travelTime = DT.ARRIVE - DT.ENROUTE) |>
  ggplot(aes(x = travelTime)) +
  facet_wrap(~REF.GRID) +
  geom_histogram(bins = 25) +
  theme_minimal()
```

```{r}
x <- x |>
  mutate(travelTime = DT.ARRIVE - DT.ENROUTE,
         shortestTime = pmin(eTT.UA.NN, eTT.UA.FN, eTT.UA.So, eTT.UA.Ce, na.rm = TRUE))

x |>
  mutate(diff = travelTime - shortestTime) |>
  filter(REF.GRID == "1 North") |>
  ggplot(aes(x = diff)) +
  geom_histogram() +
  theme_minimal()
```

```{r}
ggplot(x,aes(x=REF.GRID, y= dispToClearTime))+geom_histogram(stat= "identity",position="dodge")


# difference in travel time (station to scene vs. scene to hospital)
ggplot(x,aes(x=observedTT,y=toHospitalTT,color=REF.GRID))+geom_point()+geom_smooth()

#difference in travel time ()
ggplot(x,aes(x=atHospitalDur,y=REF.GRID,color=DISPATCH.PRIORITY.NAME))+geom_boxplot()
ggplot(x,aes(x=observedTT,y=REF.GRID,color=DISPATCH.PRIORITY.NAME))+geom_boxplot()

```

## Actual vs. Estimated

```{r}
x <- x |>
  mutate(
    # actual observed time
    actual_time = as.numeric(difftime(DT.ARRIVE, DT.DISP, units = "secs")),

    # pick the correct estimate from each provider
    est_UA = case_when(
      BASE.NAME == "Company 1" ~ eTT.UA.So,
      BASE.NAME == "Company 9" ~ eTT.UA.Ce,
      TRUE ~ NA_real_
    ),
    est_Pe = case_when(
      BASE.NAME == "Company 1" ~ eTT.Pe.So,
      BASE.NAME == "Company 9" ~ eTT.Pe.Ce,
      TRUE ~ NA_real_
    ),
    est_Op = case_when(
      BASE.NAME == "Company 1" ~ eTT.Op.So,
      BASE.NAME == "Company 9" ~ eTT.Op.Ce,
      TRUE ~ NA_real_
    ),
    est_BG = case_when(
      BASE.NAME == "Company 1" ~ eTT.BG.So,
      BASE.NAME == "Company 9" ~ eTT.BG.Ce,
      TRUE ~ NA_real_
    )
  )
```

```{r}
act_est <- x |>
  select(actual_time, est_UA, est_Pe, est_Op, est_BG, BASE.NAME) |>
  pivot_longer(
    cols = starts_with("est_"),
    names_to = "Estimator",
    values_to = "est_time"
  )
```

```{r}
metrics <- act_est |>
  group_by(Estimator) |>
  summarise(
    MAE  = mean(abs(actual_time - est_time), na.rm = TRUE),
    RMSE = sqrt(mean((actual_time - est_time)^2, na.rm = TRUE)),
    Bias = mean(actual_time - est_time, na.rm = TRUE)
  )

metrics
```

```{r}
ggplot(act_est, aes(x = est_time, y = actual_time, color = BASE.NAME)) +
  geom_point(alpha = 0.4) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
  facet_wrap(~ Estimator) +
  labs(
    title = "Actual vs. Estimated Travel Times",
    x = "Estimated travel time (seconds)",
    y = "Actual travel time (seconds)"
  ) +
  theme_minimal()
```

```{r}
act_est <- act_est |>
  mutate(error = actual_time - est_time)

ggplot(act_est, aes(x = Estimator, y = error, fill = Estimator)) +
  geom_boxplot() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Error Distribution by Estimator",
    y = "Error (seconds, actual − estimated)",
    x = "Estimator"
  ) +
  theme_minimal()
```

## Comparing scenarios

```{r}
# S0: Central + South
x$S0 <- pmin(x$eTT.UA.Ce, x$eTT.UA.So, na.rm = TRUE)

# S1: Central + Near North
x$S1 <- pmin(x$eTT.UA.Ce, x$eTT.UA.NN, na.rm = TRUE)

# S2: Central + Far North
x$S2 <- pmin(x$eTT.UA.Ce, x$eTT.UA.FN, na.rm = TRUE)

# S3: Central + South + Near North
x$S3 <- pmin(x$eTT.UA.Ce, x$eTT.UA.So, x$eTT.UA.NN, na.rm = TRUE)

# S4: Central + South + Far North
x$S4 <- pmin(x$eTT.UA.Ce, x$eTT.UA.So, x$eTT.UA.FN, na.rm = TRUE)
```

```{r}
# shortest ETT regardless of system load

shortest_ett <- x |>
  select(S0, S1, S2, S3, S4, actual_time) |>
  pivot_longer(
    cols = everything(),
    names_to = "scenario",
    values_to = "time"
  )

ggplot(shortest_ett, aes(x = time)) +
  geom_histogram(position = "identity", bins = 50) +
  labs(
    title = "Shortest Travel Time Distributions by Scenario",
    x = "Travel time (seconds)",
    y = "Count",
    fill = "Scenario"
  ) +
  theme_minimal() +
  facet_wrap(~scenario)
```

### Consider System load (dispatch rule)

```{r}
# order in dispatch time
x <- x |> arrange(DT.DISP)

# build availability matrix
avail_matrix <- outer(x$DT.DISP, x$DT.AVAILABLE, FUN = "<")
avail_matrix[upper.tri(avail_matrix, diag = TRUE)] <- FALSE
```

```{r}
dispatch_scenario <- function(x, avail_matrix, scenario_caps, ett_map, label) {
  # scenario_caps: named vector of capacities, e.g. c(South=1, Central=3, NN=2)
  # ett_map: named vector of column names in x giving ETTs for each station
  
  n_calls <- nrow(x)
  used_station <- rep(NA_character_, n_calls)
  dispatch_ett <- rep(NA_real_, n_calls)
  
  for (i in seq_len(n_calls)) {
    # reset station availability for this call
    avail_veh <- scenario_caps
    
    # check conflicts with earlier calls
    conflict_cols <- which(avail_matrix[i, ])
    if (length(conflict_cols) > 0) {
      for (j in conflict_cols) {
        st <- used_station[j]
        if (!is.na(st)) {
          avail_veh[st] <- avail_veh[st] - 1
        }
      }
    }
    
    # choose station with shortest ETT among those with capacity left
    min_ett <- Inf
    best_station <- NA
    
    for (st in names(scenario_caps)) {
      if (avail_veh[st] > 0) {
        ett_val <- x[[ett_map[st]]][i]
        if (ett_val < min_ett) {
          min_ett <- ett_val
          best_station <- st
        }
      }
    }
    
    used_station[i] <- best_station
    dispatch_ett[i] <- min_ett
  }
  
  x[[paste0(label, "_station")]] <- used_station
  x[[paste0(label, "_ETT_DISPATCH")]] <- dispatch_ett
  return(x)
}
```

```{r}
# Station → ETT column mapping
ett_map <- c(South="eTT.BG.So", Central="eTT.BG.Ce", NN="eTT.BG.NN", FN="eTT.BG.FN")

# Define scenarios (capacities per station)
S0_caps <- c(South=1, Central=3, NN=0, FN=0)
S1_caps <- c(South=0, Central=3, NN=1, FN=0)
S2_caps <- c(South=0, Central=3, NN=0, FN=1)
S3_caps <- c(South=1, Central=2, NN=1, FN=0)
S4_caps <- c(South=1, Central=2, NN=0, FN=1)

# Apply
x <- dispatch_scenario(x, avail_matrix, S0_caps, ett_map, "S0")
x <- dispatch_scenario(x, avail_matrix, S1_caps, ett_map, "S1")
x <- dispatch_scenario(x, avail_matrix, S2_caps, ett_map, "S2")
x <- dispatch_scenario(x, avail_matrix, S3_caps, ett_map, "S3")
x <- dispatch_scenario(x, avail_matrix, S4_caps, ett_map, "S4")
```

```{r}
plot_data <- x |>
  pivot_longer(cols = starts_with("S") & ends_with("ETT_DISPATCH"),
               names_to = "Scenario",
               values_to = "ETT") |>
  mutate(ETT_min = ETT / 60)

plot_data |>
  group_by(Scenario) |>
  summarise(mean_ETT = mean(ETT, na.rm = TRUE)) |>
  ggplot(aes(x = Scenario, y = mean_ETT)) +
  geom_col() +
  labs(title = "Average Dispatch ETT per Scenario",
       y = "Mean Dispatch Travel Time (sec)", x = "Scenario") +
  theme_minimal()

ggplot(plot_data, aes(x = ETT)) +
  geom_histogram(bins = 30) +
  facet_wrap(~ Scenario) +
  labs(title = "Histogram of Dispatch ETT by Scenario",
       x = "Dispatch Travel Time (sec)", y = "Count") +
  theme_minimal()
```

```{r}
plot_data <- plot_data |>
  mutate(
    DelayGroup = cut(
      ETT_min,
      breaks = c(-Inf, 6, 9, 15, Inf),
      labels = c("0–6 min", "7–9 min", "10–15 min", ">15 min")
    )
  )

counts <- plot_data |>
  group_by(Scenario, DelayGroup) |>
  summarise(N = n(), .groups = "drop")

counts
```

```{r}
library(viridis)

counts$Scenario <- gsub("_ETT_DISPATCH", "", counts$Scenario)

ggplot(counts, aes(x = DelayGroup, y = N, fill = Scenario)) +
  geom_col(position = "dodge") +
  scale_fill_viridis_d(option = "D", end = 0.9) +
  labs(title = "Counts of Dispatch Delays by Scenario",
       x = "Delay Interval", y = "Number of Calls",
       fill = "Scenario") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", hjust = 0.5)
  )

ggplot(counts, aes(x = DelayGroup, y = N, color = Scenario, group = Scenario)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  scale_color_viridis_d(option = "D", end = 0.9) +
  labs(title = "Dispatch Delay Counts by Scenario",
       x = "Delay Interval",
       y = "Number of Calls",
       color = "Scenario") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "bottom",
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 11),
    plot.title = element_text(face = "bold", hjust = 0.5)
  )
```

```{r}
 dispatch_scenario2 <- function(x, avail_matrix, scenario_caps, ett_map, label, lambda = 0.5) {
  n_calls <- nrow(x)
  used_station <- rep(NA_character_, n_calls)
  dispatch_ett <- rep(NA_real_, n_calls)

  # track how many vehicles are busy at each station over time
  busy_count <- rep(0, length(scenario_caps))
  names(busy_count) <- names(scenario_caps)
  
  for (i in seq_len(n_calls)) {
    avail_veh <- scenario_caps
    
    # check conflicts with earlier calls
    conflict_cols <- which(avail_matrix[i, ])
    if (length(conflict_cols) > 0) {
      for (j in conflict_cols) {
        st <- used_station[j]
        if (!is.na(st)) {
          avail_veh[st] <- avail_veh[st] - 1
          busy_count[st] <- busy_count[st] + 1
        }
      }
    }
    
    # choose station with lowest (ETT + λ * load penalty)
    best_station <- NA
    best_score <- Inf
    
    for (st in names(scenario_caps)) {
      if (avail_veh[st] > 0) {
        ett_val <- x[[ett_map[st]]][i]
        
        # load penalty = fraction busy at that station
        load_penalty <- busy_count[st] / scenario_caps[st]
        
        # combined score
        score <- ett_val + lambda * (load_penalty * mean(unlist(x[ett_map]), na.rm = TRUE))
        # scale penalty roughly to seconds
        if (score < best_score) {
          best_score <- score
          best_station <- st
        }
      }
    }
    
    used_station[i] <- best_station
    dispatch_ett[i] <- x[[ett_map[best_station]]][i]
  }
  
  x[[paste0(label, "_station")]] <- used_station
  x[[paste0(label, "_ETT_DISPATCH")]] <- dispatch_ett
  return(x)
}

```

```{r}
# Station → ETT column mapping
ett_map <- c(South="eTT.BG.So", Central="eTT.BG.Ce", NN="eTT.BG.NN", FN="eTT.BG.FN")

# Define scenarios (capacities per station)
S0_caps <- c(South=1, Central=3, NN=0, FN=0)
S1_caps <- c(South=0, Central=3, NN=1, FN=0)
S2_caps <- c(South=0, Central=3, NN=0, FN=1)
S3_caps <- c(South=1, Central=2, NN=1, FN=0)
S4_caps <- c(South=1, Central=2, NN=0, FN=1)

x2 <- x |> arrange(DT.DISP)

# Apply
x2 <- dispatch_scenario2(x2, avail_matrix, S0_caps, ett_map, "S0")
x2 <- dispatch_scenario2(x2, avail_matrix, S1_caps, ett_map, "S1")
x2 <- dispatch_scenario2(x2, avail_matrix, S2_caps, ett_map, "S2")
x2 <- dispatch_scenario2(x2, avail_matrix, S3_caps, ett_map, "S3")
x2 <- dispatch_scenario2(x2, avail_matrix, S4_caps, ett_map, "S4")

plot_data2 <- x2 |>
  pivot_longer(cols = starts_with("S") & ends_with("ETT_DISPATCH"),
               names_to = "Scenario",
               values_to = "ETT") |>
  mutate(ETT_min = ETT / 60)

plot_data2 <- plot_data2 |>
  mutate(
    DelayGroup = cut(
      ETT_min,
      breaks = c(-Inf, 6, 9, 15, Inf),
      labels = c("0–6 min", "7–9 min", "10–15 min", ">15 min")
    )
  )

counts2 <- plot_data2 |>
  group_by(Scenario, DelayGroup) |>
  summarise(N = n(), .groups = "drop")

```

```{r}

counts2$Scenario <- gsub("_ETT_DISPATCH", "", counts$Scenario)

ggplot(counts2, aes(x = DelayGroup, y = N, fill = Scenario)) +
  geom_col(position = "dodge") +
  scale_fill_viridis_d(option = "D", end = 0.9) +
  labs(title = "Counts of Dispatch Rule 2 Delays by Scenario",
       x = "Delay Interval", y = "Number of Calls",
       fill = "Scenario") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", hjust = 0.5)
  )

ggplot(counts2, aes(x = DelayGroup, y = N, color = Scenario, group = Scenario)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  scale_color_viridis_d(option = "D", end = 0.9) +
  labs(title = "Dispatch Rule 2 Delay Counts by Scenario",
       x = "Delay Interval",
       y = "Number of Calls",
       color = "Scenario") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "bottom",
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 11),
    plot.title = element_text(face = "bold", hjust = 0.5)
  )
```

## Mapping Plots
```{r}
library(sf)
library(ggplot2)
library (dplyr)
library(rnaturalearth)
library(rnaturalearthdata)
library(tigris)
library(leaflet)
        
ggplot(x,aes(x=REF.GPS.LON,y=REF.GPS.LAT))+geom_point(color="blue",size=3)+
theme_minimal()+
  coord_fixed()

sf_vals<- st_as_sf(x,coords= c("REF.GPS.LON","REF.GPS.LAT"),crs=4326)

plot(sf_vals["observedTT"])

leaflet(x) |> 
  addTiles() |> 
  addCircleMarkers(~REF.GPS.LON, ~REF.GPS.LAT, popup = ~as.character(REF.GPS.LON))



```

### Static Map Plot

```{r echo=FALSE}

library(dplyr)
library(sf)
library(ggplot2)
library(tigris)

options(tigris_use_cache = TRUE)

vance_data <- counties(state = "NC", year = 2024, class = "sf") |> filter(GEOID == "37181")

x_modified <- x |>
  mutate(obsTTmodified = as.numeric(observedTT, units = "mins"))

coords_df<- st_as_sf(x_modified, coords = c("REF.GPS.LON","REF.GPS.LAT"), crs = 4326, remove = FALSE) |> st_transform(st_crs(vance_data))


road_df <- roads(state = "NC", county = "Vance", year = 2024, class = "sf")


plot_save <- ggplot() +
  geom_sf(data = vance_data, fill = NA, color = "black", linewidth = 0.5) + geom_sf(data = road_df, color = "grey80", linewidth = 0.2) +
  geom_sf(data = coords_df, aes(color = obsTTmodified), size = 1.8) +
  scale_color_viridis_c(name = "Observed EMS Travel Time (minutes)", na.value = "grey80") +
  coord_sf(xlim = st_bbox(vance_data)[c("xmin","xmax")],
           ylim = st_bbox(vance_data)[c("ymin","ymax")], expand = FALSE) +
  labs(title= "Observed Travel Times of Vance County EMS in minutes")+
  theme_minimal(base_size = 12) +
  theme(panel.grid.major = element_blank(),
        axis.title = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())

ggsave("vance_county_ems_observedtravel.png", plot_save, width = 7, height = 7, dpi = 300)

```

### Static Map Plot Emergency/Non Emergency

```{r echo=FALSE}

library(dplyr)
library(sf)
library(ggplot2)
library(tigris)

options(tigris_use_cache = TRUE)

vance_data <- counties(state = "NC", year = 2024, class = "sf") |> filter(GEOID == "37181")

x_modified <- x |>
  mutate(obsTTmodified = as.numeric(observedTT, units = "mins"))

coords_df<- st_as_sf(x_modified, coords = c("REF.GPS.LON","REF.GPS.LAT"), crs = 4326, remove = FALSE) |> st_transform(st_crs(vance_data))


road_df <- roads(state = "NC", county = "Vance", year = 2024, class = "sf")


plot_save <- ggplot() +
  geom_sf(data = vance_data, fill = NA, color = "black", linewidth = 0.5) + geom_sf(data = road_df, color = "grey80", linewidth = 0.2) +
  geom_sf(data = coords_df, aes(color = DISPATCH.PRIORITY.NAME), size = 1.8) +
  coord_sf(xlim = st_bbox(vance_data)[c("xmin","xmax")],
           ylim = st_bbox(vance_data)[c("ymin","ymax")], expand = FALSE) +
  labs(title= "Urgency of Vance County EMS Calls",color="Urgency Level")+
  theme_minimal(base_size = 12) +
  theme(panel.grid.major = element_blank(),
        axis.title = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())

ggsave("vance_county_ems_urgency.png", plot_save, width = 7, height = 7, dpi = 300)
```

```{r}
ggplot(x,aes(x=REF.GRID,fill=DISPATCH.PRIORITY.NAME))+geom_histogram(stat="count",position = "dodge")+labs(title="Emergency/Non-Emergency EMS Calls by Region",x="Region",y="Count",fill="Urgency Level") + theme_minimal()
```

# Modeling Dispatch Rule 1
```{r}
x <- x |>
  mutate(obsTTmodified = as.numeric(observedTT, units = "mins"))
# Hierarchical LMM
library(lme4)
lme.out<-lmer(obsTTmodified~(1|REF.GRID)+DISPATCH.PRIORITY.NAME,data=x)
summary(lme.out)
x<-x|>mutate(region_category= case_when(
  REF.GRID== "1 North"~"North",
  REF.GRID=="2 Central"~"Central",
  REF.GRID =="3 South"~"South"
  
))
#GLS
library(nlme)
gls.out<-nlme::gls(obsTTmodified~DISPATCH.PRIORITY.NAME,corr=corCompSymm(value=0.5,form=~1|region_category),data=x, na.action=na.omit)
summary(gls.out)
#par(mfrow=c(1,2),las=1)
#qqnorm(residuals(lme.out),main="Residuals")
#qqnorm(unlist(ranef(lme.out)$region_category),main="Random Effects")
```
# Modeling Dispatch Rule 2
```{r}
x2 <- x2 |>
  mutate(obsTTmodified = as.numeric(observedTT, units = "mins"))
# Hierarchical LMM 
library(lme4)
lme.out<-lmer(obsTTmodified~(1|REF.GRID)+DISPATCH.PRIORITY.NAME,data=x2)
summary(lme.out)
x2<-x2|>mutate(region_category= case_when(
  REF.GRID== "1 North"~"North",
  REF.GRID=="2 Central"~"Central",
  REF.GRID =="3 South"~"South"
  
))
#GLS
library(nlme)
gls.out<-nlme::gls(obsTTmodified~DISPATCH.PRIORITY.NAME,corr=corCompSymm(value=0.5,form=~1|region_category),data=x2, na.action=na.omit)
summary(gls.out)
#par(mfrow=c(1,2),las=1)
#qqnorm(residuals(lme.out),main="Residuals")
#qqnorm(unlist(ranef(lme.out)$region_category),main="Random Effects")
```