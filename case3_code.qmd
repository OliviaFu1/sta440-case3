---
title: "Sta 440 Case 3"
author: "Srika Gopal, Olivia Fu, Steph Reinke"
date: "October 2025"
format: 
  pdf:
    documentclass: article
    fontsize: 11pt
geometry: margin=1in
execute: 
  warning: false
  message: false
  echo: false
---

# 1. Background

Emergency medical service (EMS) response times can drastically impact patient outcomes. Vance County, North Carolina is a growing county that is interested in evaluating their current EMS ambulance placements. The county has three major regions, the North, Central, and the South. The population is mostly concentrated in the city of Henderson, located in the Central region. There are currently 2 EMS stations, 1 in the South, and 1 in Central. The southern station has 1 ambulance, and the central station has 3. The North does not currently have a station. Thus Vance County is interested in exploring if moving an ambulance to the North would be beneficial. There are two potential locations for an ambulance to be stationed in the North: the Near North and the Far North. We were given five scenarios for ambulance placement:

-   Scenario 0: 1 in South, 3 in Central (Current Placement)
-   Scenario 1: 0 in South, 3 in Central, 1 in Near North
-   Scenario 2: 0 in South, 3 in Central, 1 in Far North
-   Scenario 3: 1 in South, 2 in Central, 1 in Near North
-   Scenario 4: 1 in South, 2 in Central, 1 in Far North

**Research question:** Where should the ambulances be stationed to best serve Vance county?

```{r}
#| label: packages

library(tidyverse)
library(ggplot2)
library(dplyr)
library(tidyr)

```

# 2. Data and Model Fit

To answer this question we examined a dataset with real EMS call data. Select information was withheld or changed, such as dates and addresses for HIPAA compliance. However for the purposes of our analysis those changes are not relevant. The data has information for each call and API pulled travel times from Google Maps. We were provided with four types of estimates from Google Maps (best guess, optimistic, pessimistic, and unadjusted) for each station including the two proposed Northern stations to each call.

```{r}
#| label: read_data

load("./emsData.RData")

```

```{r}
#| label: data

# remove duplicated entries of the same call
# 5 duplicates
x <- x |>
  distinct(VEH.GRID, DT.DISP, .keep_all = TRUE)

```

```{r}
#| label: problems_in_north

x |>
  mutate(travelTime = DT.ARRIVE - DT.ENROUTE) |>
  ggplot(aes(x = travelTime)) +
  facet_wrap(~REF.GRID) +
  geom_histogram(bins = 25) +
  theme_minimal()

```

```{r}
x <- x |>
  mutate(travelTime = DT.ARRIVE - DT.ENROUTE,
         shortestTime = pmin(eTT.UA.NN, eTT.UA.FN, eTT.UA.So, eTT.UA.Ce, na.rm = TRUE))

x |>
  mutate(diff = travelTime - shortestTime) |>
  filter(REF.GRID == "1 North") |>
  ggplot(aes(x = diff)) +
  geom_histogram() +
  theme_minimal()
```

```{r}
ggplot(x,aes(x=REF.GRID, y= dispToClearTime))+geom_histogram(stat= "identity",position="dodge")


# difference in travel time (station to scene vs. scene to hospital)
ggplot(x,aes(x=observedTT,y=toHospitalTT,color=REF.GRID))+geom_point()+geom_smooth()

#difference in travel time ()
ggplot(x,aes(x=atHospitalDur,y=REF.GRID,color=DISPATCH.PRIORITY.NAME))+geom_boxplot()
ggplot(x,aes(x=observedTT,y=REF.GRID,color=DISPATCH.PRIORITY.NAME))+geom_boxplot()

```

```{r}
#| label: estmiated_vs_actual

x <- x |>
  mutate(
    # actual observed time
    actual_time = as.numeric(difftime(DT.ARRIVE, DT.DISP, units = "secs")),

    # pick the correct estimate from each provider
    est_UA = case_when(
      BASE.NAME == "Company 1" ~ eTT.UA.So,
      BASE.NAME == "Company 9" ~ eTT.UA.Ce,
      TRUE ~ NA_real_
    ),
    est_Pe = case_when(
      BASE.NAME == "Company 1" ~ eTT.Pe.So,
      BASE.NAME == "Company 9" ~ eTT.Pe.Ce,
      TRUE ~ NA_real_
    ),
    est_Op = case_when(
      BASE.NAME == "Company 1" ~ eTT.Op.So,
      BASE.NAME == "Company 9" ~ eTT.Op.Ce,
      TRUE ~ NA_real_
    ),
    est_BG = case_when(
      BASE.NAME == "Company 1" ~ eTT.BG.So,
      BASE.NAME == "Company 9" ~ eTT.BG.Ce,
      TRUE ~ NA_real_
    )
  )

```

```{r}
act_est <- x |>
  select(actual_time, est_UA, est_Pe, est_Op, est_BG, BASE.NAME) |>
  pivot_longer(
    cols = starts_with("est_"),
    names_to = "Estimator",
    values_to = "est_time"
  )
```

```{r}
metrics <- act_est |>
  group_by(Estimator) |>
  summarise(
    MAE  = mean(abs(actual_time - est_time), na.rm = TRUE),
    RMSE = sqrt(mean((actual_time - est_time)^2, na.rm = TRUE)),
    Bias = mean(actual_time - est_time, na.rm = TRUE)
  )

metrics
```

```{r}
ggplot(act_est, aes(x = est_time, y = actual_time, color = BASE.NAME)) +
  geom_point(alpha = 0.4) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
  facet_wrap(~ Estimator) +
  labs(
    title = "Actual vs. Estimated Travel Times",
    x = "Estimated travel time (seconds)",
    y = "Actual travel time (seconds)"
  ) +
  theme_minimal()
```

```{r}
act_est <- act_est |>
  mutate(error = actual_time - est_time)

ggplot(act_est, aes(x = Estimator, y = error, fill = Estimator)) +
  geom_boxplot() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Error Distribution by Estimator",
    y = "Error (seconds, actual − estimated)",
    x = "Estimator"
  ) +
  theme_minimal()
```

```{r}
#| label: comparing_scenarios

# S0: Central + South
x$S0 <- pmin(x$eTT.BG.Ce, x$eTT.BG.So, na.rm = TRUE)

# S1: Central + Near North
x$S1 <- pmin(x$eTT.BG.Ce, x$eTT.BG.NN, na.rm = TRUE)

# S2: Central + Far North
x$S2 <- pmin(x$eTT.BG.Ce, x$eTT.BG.FN, na.rm = TRUE)

# S3: Central + South + Near North
x$S3 <- pmin(x$eTT.BG.Ce, x$eTT.BG.So, x$eTT.BG.NN, na.rm = TRUE)

# S4: Central + South + Far North
x$S4 <- pmin(x$eTT.BG.Ce, x$eTT.BG.So, x$eTT.BG.FN, na.rm = TRUE)

```

```{r}
# shortest ETT regardless of system load

shortest_ett <- x |>
  select(S0, S1, S2, S3, S4, actual_time) |>
  pivot_longer(
    cols = everything(),
    names_to = "scenario",
    values_to = "time"
  )

ggplot(shortest_ett, aes(x = time)) +
  geom_histogram(position = "identity", bins = 50) +
  labs(
    title = "Shortest Travel Time Distributions by Scenario",
    x = "Travel time (seconds)",
    y = "Count",
    fill = "Scenario"
  ) +
  theme_minimal() +
  facet_wrap(~scenario)
```

```{r}
#| label: consider_load_dispatch

# order in dispatch time
x <- x |> arrange(DT.DISP)

# build availability matrix
avail_matrix <- outer(x$DT.DISP, x$DT.AVAILABLE, FUN = "<")
avail_matrix[upper.tri(avail_matrix, diag = TRUE)] <- FALSE

```

```{r}
dispatch_scenario <- function(x, avail_matrix, scenario_caps, ett_map, label) {
  # scenario_caps: named vector of capacities, e.g. c(South=1, Central=3, NN=2)
  # ett_map: named vector of column names in x giving ETTs for each station
  
  n_calls <- nrow(x)
  used_station <- rep(NA_character_, n_calls)
  dispatch_ett <- rep(NA_real_, n_calls)
  
  for (i in seq_len(n_calls)) {
    # reset station availability for this call
    avail_veh <- scenario_caps
    
    # check conflicts with earlier calls
    conflict_cols <- which(avail_matrix[i, ])
    if (length(conflict_cols) > 0) {
      for (j in conflict_cols) {
        st <- used_station[j]
        if (!is.na(st)) {
          avail_veh[st] <- avail_veh[st] - 1
        }
      }
    }
    
    # choose station with shortest ETT among those with capacity left
    min_ett <- Inf
    best_station <- NA
    
    for (st in names(scenario_caps)) {
      if (avail_veh[st] > 0) {
        ett_val <- x[[ett_map[st]]][i]
        if (ett_val < min_ett) {
          min_ett <- ett_val
          best_station <- st
        }
      }
    }
    
    used_station[i] <- best_station
    dispatch_ett[i] <- min_ett
  }
  
  x[[paste0(label, "_station")]] <- used_station
  x[[paste0(label, "_ETT_DISPATCH")]] <- dispatch_ett
  return(x)
}
```

```{r}
# Station → ETT column mapping
ett_map <- c(South="eTT.BG.So", Central="eTT.BG.Ce", NN="eTT.BG.NN", FN="eTT.BG.FN")

# Define scenarios (capacities per station)
S0_caps <- c(South=1, Central=3, NN=0, FN=0)
S1_caps <- c(South=0, Central=3, NN=1, FN=0)
S2_caps <- c(South=0, Central=3, NN=0, FN=1)
S3_caps <- c(South=1, Central=2, NN=1, FN=0)
S4_caps <- c(South=1, Central=2, NN=0, FN=1)

# Apply
x <- dispatch_scenario(x, avail_matrix, S0_caps, ett_map, "S0")
x <- dispatch_scenario(x, avail_matrix, S1_caps, ett_map, "S1")
x <- dispatch_scenario(x, avail_matrix, S2_caps, ett_map, "S2")
x <- dispatch_scenario(x, avail_matrix, S3_caps, ett_map, "S3")
x <- dispatch_scenario(x, avail_matrix, S4_caps, ett_map, "S4")
```

```{r}
plot_data <- x |>
  pivot_longer(cols = starts_with("S") & ends_with("ETT_DISPATCH"),
               names_to = "Scenario",
               values_to = "ETT") |>
  mutate(ETT_min = ETT / 60)

plot_data |>
  group_by(Scenario) |>
  summarise(mean_ETT = mean(ETT, na.rm = TRUE)) |>
  ggplot(aes(x = Scenario, y = mean_ETT)) +
  geom_col() +
  labs(title = "Average Dispatch ETT per Scenario",
       y = "Mean Dispatch Travel Time (sec)", x = "Scenario") +
  theme_minimal()

ggplot(plot_data, aes(x = ETT)) +
  geom_histogram(bins = 30) +
  facet_wrap(~ Scenario) +
  labs(title = "Histogram of Dispatch ETT by Scenario",
       x = "Dispatch Travel Time (sec)", y = "Count") +
  theme_minimal()
```

```{r}
plot_data <- plot_data |>
  mutate(
    DelayGroup = cut(
      ETT_min,
      breaks = c(-Inf, 6, 9, 15, Inf),
      labels = c("0–6 min", "7–9 min", "10–15 min", ">15 min")
    )
  )

counts <- plot_data |>
  group_by(Scenario, DelayGroup) |>
  summarise(N = n(), .groups = "drop")

counts
```

```{r}
library(viridis)

counts$Scenario <- gsub("_ETT_DISPATCH", "", counts$Scenario)

ggplot(counts, aes(x = DelayGroup, y = N, fill = Scenario)) +
  geom_col(position = "dodge") +
  scale_fill_viridis_d(option = "D", end = 0.9) +
  labs(title = "Counts of Dispatch Delays by Scenario",
       x = "Delay Interval", y = "Number of Calls",
       fill = "Scenario") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", hjust = 0.5)
  )

ggplot(counts, aes(x = DelayGroup, y = N, color = Scenario, group = Scenario)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  scale_color_viridis_d(option = "D", end = 0.9) +
  labs(title = "Dispatch Delay Counts by Scenario",
       x = "Delay Interval",
       y = "Number of Calls",
       color = "Scenario") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "bottom",
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 11),
    plot.title = element_text(face = "bold", hjust = 0.5)
  )
```

```{r echo=FALSE}
#| label: static_map_plot

library(dplyr)
library(sf)
library(ggplot2)
library(tigris)

options(tigris_use_cache = TRUE)

vance_data <- counties(state = "NC", year = 2024, class = "sf") |> filter(GEOID == "37181")

x_modified <- x |>
  mutate(obsTTmodified = as.numeric(observedTT, units = "mins"))

coords_df<- st_as_sf(x_modified, coords = c("REF.GPS.LON","REF.GPS.LAT"), crs = 4326, remove = FALSE) |> st_transform(st_crs(vance_data))


road_df <- roads(state = "NC", county = "Vance", year = 2024, class = "sf")


plot_save <- ggplot() +
  geom_sf(data = vance_data, fill = NA, color = "black", linewidth = 0.5) + geom_sf(data = road_df, color = "grey80", linewidth = 0.2) +
  geom_sf(data = coords_df, aes(color = obsTTmodified), size = 1.8) +
  scale_color_viridis_c(name = "Observed EMS Travel Time (minutes)", na.value = "grey80") +
  coord_sf(xlim = st_bbox(vance_data)[c("xmin","xmax")],
           ylim = st_bbox(vance_data)[c("ymin","ymax")], expand = FALSE) +
  labs(title= "Observed Travel Times of Vance County EMS in minutes")+
  theme_minimal(base_size = 12) +
  theme(panel.grid.major = element_blank(),
        axis.title = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())

ggsave("vance_county_ems_observedtravel.png", plot_save, width = 7, height = 7, dpi = 300)

```

```{r echo=FALSE}
#| label: static_map_plot_emergency_vs_non

library(dplyr)
library(sf)
library(ggplot2)
library(tigris)

options(tigris_use_cache = TRUE)

vance_data <- counties(state = "NC", year = 2024, class = "sf") |> filter(GEOID == "37181")

x_modified <- x |>
  mutate(obsTTmodified = as.numeric(observedTT, units = "mins"))

coords_df<- st_as_sf(x_modified, coords = c("REF.GPS.LON","REF.GPS.LAT"), crs = 4326, remove = FALSE) |> st_transform(st_crs(vance_data))


road_df <- roads(state = "NC", county = "Vance", year = 2024, class = "sf")


plot_save <- ggplot() +
  geom_sf(data = vance_data, fill = NA, color = "black", linewidth = 0.5) + geom_sf(data = road_df, color = "grey80", linewidth = 0.2) +
  geom_sf(data = coords_df, aes(color = DISPATCH.PRIORITY.NAME), size = 1.8) +
  coord_sf(xlim = st_bbox(vance_data)[c("xmin","xmax")],
           ylim = st_bbox(vance_data)[c("ymin","ymax")], expand = FALSE) +
  labs(title= "Urgency of Vance County EMS Calls",color="Urgency Level")+
  theme_minimal(base_size = 12) +
  theme(panel.grid.major = element_blank(),
        axis.title = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())

ggsave("vance_county_ems_urgency.png", plot_save, width = 7, height = 7, dpi = 300)

```

```{r}
ggplot(x,aes(x=REF.GRID,fill=DISPATCH.PRIORITY.NAME))+geom_histogram(stat="count",position = "dodge")+labs(title="Emergency/Non-Emergency EMS Calls by Region",x="Region",y="Count",fill="Urgency Level") + theme_minimal()
```

```{r}
#| label: start_of_modeling

x <- x |>
  mutate(obsTTmodified = as.numeric(observedTT, units = "mins"))

x<-x|>
  mutate(region_category= case_when(
    REF.GRID== "1 North"~"North",
    REF.GRID=="2 Central"~"Central",
    REF.GRID =="3 South"~"South"
))

# Hierarchical LMM
library(lme4)
lme.out<-lmer(obsTTmodified~(1|REF.GRID)+DISPATCH.PRIORITY.NAME,data=x)
summary(lme.out)


#GLS
library(nlme)
gls.out<-nlme::gls(obsTTmodified~DISPATCH.PRIORITY.NAME,corr=corCompSymm(value=0.5,form=~1|region_category),data=x, na.action=na.omit)
summary(gls.out)
```

```{r}
library(dplyr)
library(tidyr)
library(stringr)
library(lme4)
library(emmeans)

model_df <- x |>
  transmute(
    row_val = row_number(),region_category, DISPATCH.PRIORITY.NAME,
    across(matches("^S\\d+_ETT_DISPATCH$"))
  ) |>
  pivot_longer(
    cols = matches("^S\\d+_ETT_DISPATCH$"),
    names_to = "Scenario",
    values_to = "ETT_sec"
  ) |>
  dplyr::mutate(
    Scenario        = str_remove(Scenario, "_ETT_DISPATCH$"),
    Scenario        = factor(Scenario),
    region_category = factor(region_category),
    ETT_min         = ETT_sec / 60
  )

model_df <- model_df |>
  group_by(row_val) |>
  mutate(
    change_flag = (max(ETT_sec) != min(ETT_sec))  # TRUE if not all equal
  ) |>
  ungroup()
```

```{r}
#| label: logistic_reg

# logistic model
model_logit <- glm(change_flag ~ region_category + DISPATCH.PRIORITY.NAME, 
                   data = model_df, 
                   family = binomial)
summary(model_logit)

```

```{r}
#| label: linear_mixed_model

library(lmerTest)

lmm_model <- lmer(
  log(ETT_sec) ~ Scenario + region_category + DISPATCH.PRIORITY.NAME + (1 | row_val),
  data = model_df
)
summary(lmm_model)

```

```{r}
model_df$fitted <- fitted(lmm_model)
model_df$resid  <- resid(lmm_model)

ggplot(model_df, aes(x = fitted, y = resid)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(title = "Residuals vs Fitted",
       x = "Fitted values",
       y = "Residuals")

ggplot(model_df, aes(x = Scenario, y = resid)) +
  geom_boxplot() +
  labs(title = "Residuals by Scenario",
       x = "Scenario", y = "Residuals")

ggplot(model_df, aes(x = region_category, y = resid)) +
  geom_boxplot() +
  labs(title = "Residuals by Region",
       x = "Region", y = "Residuals")

hist(model_df$ETT_sec, breaks = 50)
hist(log(model_df$ETT_sec), breaks = 50)

# Residuals Q-Q plot
qqnorm(residuals(lmm_model), main = "Residuals")
qqline(residuals(lmm_model), col = "red")

# Random effects Q-Q plot
qqnorm(unlist(ranef(lmm_model)$row_val), main = "Random Effects")
qqline(unlist(ranef(lmm_model)$row_val), col = "red")
```

```{r}
#| label: only_calls_with_different_ETT_across_scenarios

changed_df <- model_df |> filter(change_flag)

lmm_model_changed <- lmer(
  ETT_sec ~ Scenario + region_category + DISPATCH.PRIORITY.NAME + (1 | row_val),
  data = changed_df
)
summary(lmm_model_changed)

changed_df$fitted <- fitted(lmm_model_changed)
changed_df$resid  <- resid(lmm_model_changed)

ggplot(changed_df, aes(x = fitted, y = resid)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(title = "Residuals vs Fitted",
       x = "Fitted values",
       y = "Residuals")

ggplot(changed_df, aes(x = Scenario, y = resid)) +
  geom_boxplot() +
  labs(title = "Residuals by Scenario",
       x = "Scenario", y = "Residuals")

ggplot(changed_df, aes(x = region_category, y = resid)) +
  geom_boxplot() +
  labs(title = "Residuals by Region",
       x = "Region", y = "Residuals")

qqnorm(resid(lmm_model_changed))
qqline(resid(lmm_model_changed), col = "red")

hist(changed_df$ETT_sec, breaks = 50)

```

```{r}
#| label: GLS

library(nlme)

gls_model <- gls(
  ETT_sec ~ Scenario + region_category + DISPATCH.PRIORITY.NAME,
  data = model_df
)

model_df$gls_fitted <- fitted(gls_model)
model_df$gls_resid  <- resid(gls_model)

ggplot(model_df, aes(x = gls_fitted, y = gls_resid)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(title = "Residuals vs Fitted",
       x = "Fitted values",
       y = "Residuals")

ggplot(model_df, aes(x = Scenario, y = gls_resid)) +
  geom_boxplot() +
  labs(title = "Residuals by Scenario",
       x = "Scenario", y = "Residuals")

ggplot(model_df, aes(x = region_category, y = gls_resid)) +
  geom_boxplot() +
  labs(title = "Residuals by Region",
       x = "Region", y = "Residuals")

qqnorm(resid(gls_model))
qqline(resid(gls_model), col = "red")
```

```{r}
gls_model_region <- gls(
  ETT_sec ~ Scenario*region_category + DISPATCH.PRIORITY.NAME,
  data = model_df, method = "REML",
  weights = varIdent(form = ~ 1 | region_category)
)

anova(gls_model, gls_model_region)
```

```{r}
gls_model_pow <- gls(
  ETT_sec ~ Scenario*region_category + DISPATCH.PRIORITY.NAME,
  data = model_df, method = "REML",
  weights = varPower(form = ~ fitted(.))   # variance ∝ mean^δ
)

anova(gls_model, gls_model_pow)
```

```{r}
#| label: anova_gls_vs_lmm

#anova gls and original lmm
anova(lmm_model,gls_model)
AIC(lmm_model,gls_model)
BIC(lmm_model,gls_model)

#anova gls_model_pow and original lmm
anova(lmm_model,gls_model_pow)
AIC(lmm_model,gls_model_pow)
BIC(lmm_model,gls_model_pow)


#anova gls and lmm_model changed
anova(lmm_model_changed,gls_model)
AIC(lmm_model_changed,gls_model)
BIC(lmm_model_changed,gls_model)

#anova gls_model_pow and lmm_model_changed
anova(lmm_model_changed,gls_model_pow)
AIC(lmm_model_changed,gls_model_pow)
BIC(lmm_model_changed,gls_model_pow)

```

```{r}
#| label: setup_for_comparisions

library(nlme)

lmm_model_ext <- lme(
  log(ETT_sec) ~ Scenario + region_category + DISPATCH.PRIORITY.NAME,
  random = ~1 | row_val,                           # random intercept per call
  weights = varIdent(form = ~1 | region_category), # different variance per region
  data = model_df
)

# Residuals Q-Q plot
qqnorm(residuals(lmm_model_ext), main = "Residuals")
qqline(residuals(lmm_model_ext), col = "red")

# Random effects Q-Q plot
re <- ranef(lmm_model_ext)
qqnorm(re[,1], main = "Random Effects")
qqline(re[,1], col = "red")

lmm_no_weights <- lme(
  log(ETT_sec) ~ Scenario + region_category + DISPATCH.PRIORITY.NAME,
  random = ~1 | row_val,
  data = model_df
)


lmm_interaction<-lme(
  log(ETT_sec) ~ Scenario*region_category + DISPATCH.PRIORITY.NAME,
  random = ~1 | row_val,                           
  weights = varIdent(form = ~1 | region_category), 
  data = model_df
)

lmm_no_dispatch_name_no_interaction<-lme(
  log(ETT_sec) ~ Scenario+ region_category,
  random = ~1 | row_val,                           
  weights = varIdent(form = ~1 | region_category), 
  data = model_df
)

lmm_no_dispatch_name_interaction<-lme(
  log(ETT_sec) ~ Scenario*region_category,
  random = ~1 | row_val,                           
  weights = varIdent(form = ~1 | region_category), 
  data = model_df
)

anova(lmm_no_weights, lmm_model_ext)

```

# 4. Assumptions and Shortcomings

Normality of residuals was poorly met Large deviances at tails Non-constant variance across fitted values External factors not taken into consideration Traffic / Rush hours/ Road closures Time of year EMT staffing patterns ETT inputs: based on single best-guess estimates (e.g., from Google), lacking nuance or uncertainty Variance modeling: only accounted for regional differences, while other factors may also influence variability Emergency vs non-emergency Simplicity in Dispatch Rule Better for analysis Doesn’t occur in real life

# 5. Conclusions

Scenario 3 results in the fastest overall response times Marginal mean travel times (ETTs) are reduced by \~16% compared with the baseline (Scenario 0)

exp (−0.173) ≈ 0.84 → travel times in Scenario 3 are about 84% of baseline levels
